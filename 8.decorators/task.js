function cachingDecoratorNew(func) {
  let cache = [];

  return function wrapper(...args) {
    let hash = args.join(',');
    let idx = cache.findIndex((item) => item.hash === hash);
    if (idx !== -1) {
      console.log(`Из кэша: ${cache[idx].result}`);
      return `Из кэша: ${cache[idx].result}`;
    }
    let result = func(...args);
    cache.push({ hash, result });
    if (cache.length > 5) {
      cache.shift();
    }
    console.log("Вычисляем: " + result);
    return "Вычисляем: " + result;
  }
}

/*
Усовершенствуйте рассмотренный на лекции debounce декоратор таким образом, чтобы первый его вызов происходил моментально
 а следующий не раньше чем через интервал времени, причем интервал должен задаваться в момент применения декоратора к функции. 
 Такие декораторы называются "Leading edge" или "immediate" (немедленный). Они применяется если события, например отправка информации, происходит слишком часто.

Подсказка 1
Вызывайте переданную функцию немедленно и взводите флаг.
Подсказка 2
Используйте setTimeout для снятия флага и при каждом вызове проверяйте, взведен ли он.
 
 Вам нужно сначала сбросить текущий таймаут, затем создать новый (чтобы спустя время функция вызывалась)
 и только после этих действий проверять флаг: если он опущен, то синхронно вызывать полученную функцию. 
 Вот пример из презентации, вы можете использовать его, только замер времени будет лишним. 

 К этому декоратору (из примера со слайда) необходимо добавить вызов синхронной функции (при первом вызове).
 */

/*function debounceDecoratorNew(func, ms) {
  let flag = false;

  return function wrapper(...args) {
    if (flag === false) {
      func.apply(this, args);
    }
    flag = true;
    setTimeout(() => flag = false, ms);
  };
}*/

function debounceDecoratorNew(func, ms) {
  let flag = false;
  let timeout;

  return function wrapper(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), ms);

    if (flag === false) {
      func.apply(this, args);
      flag = true;
    } else {
      return timeout;
    }
  };
}

const sendSignal = () => console.log("Сигнал отправлен");
const upgradedSendSignal = debounceDecoratorNew2(sendSignal, 2000);
setTimeout(upgradedSendSignal); // Сигнал отправлен
setTimeout(upgradedSendSignal, 300); // проигнорировано так как от последнего вызова прошло менее 2000мс (300 - 0 < 2000)
setTimeout(upgradedSendSignal, 900); // проигнорировано так как времени от последнего вызова прошло: 900-300=600 (600 < 2000)
setTimeout(upgradedSendSignal, 1200); // проигнорировано так как времени от последнего вызова прошло: 1200-900=300 (300 < 2000)
setTimeout(upgradedSendSignal, 2300); // проигнорировано так как времени от последнего вызова прошло: 2300-1200=1100 (1100 < 2000)
setTimeout(upgradedSendSignal, 4400); // Сигнал отправлен так как времени от последнего вызова прошло: 4400-2300=2100 (2100 > 2000)
setTimeout(upgradedSendSignal, 4500); // Сигнал будет отправлен, так как последний вызов debounce декоратора (спустя 4500 + 2000 = 6500) 6,5с



/*Представьте ситуацию, что пользователь очень часто нажимает отправить, при этом наш debounce декоратор отправляет сообщения не чаще чем раз в интервал времени, 
но мы хотим дополнительно знать, сколько всего раз была вызвана исходная функция. Усовершенствуйте декоратор из задания 2 таким образом, чтобы в свойстве count 
декорированной функции хранилось количество вызовов. Для решения используйте подход, который был применен в лекции для декоратора-шпиона. Усовершенствованный 
декоратор должен называться debounceDecorator2.

Подсказка 1
Добавьте к обертке wrapper новое свойство count в котором храните количество вызовов.

В третьем задании, вы реализовали часть шпионского декоратора, сохраняя все аргументы.
По заданию, вам требовалось сохранять не аргументы, а количество вызовов. 
То есть вам нужно присвоить начальное значение не пустой массив, а число ноль,
а затем увеличивать эту переменную. Так же, вам следовало считать количество вызовов переданной функции…
Количество вызовов декоратора можно реализовать и во внешнем коде (который будет использовать декоратор), 
а вот количество вызовов переданной функции, во вне не посчитать (так как некоторые вызовы выполняются синхронно, 
а некоторые асинхронно). То есть на один вызов декоратора может быть два вызова полученной функции (синхронный и спустя промежуток времени, асинхронный), 
так и вообще ни одного, если синхронный вызов выполнялся (флаг возведён) и вызывается ещё вызов декоратора (новый вызов будет удалять предыдущий интервал). 
В таком вызове, переданная функция вообще не вызовется. */


function debounceDecoratorNew2(func, ms) {
  let flag = false;
  let timeout;
  function wrapper(...args) {
    wrapper.count++;
    console.log(`Исходная функция была вызвана ${wrapper.count}`);
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), ms);

    if (flag === false) {
      func.apply(this, args);
      flag = true;
    } else {
      return timeout;
    }
  };
  wrapper.count = 0;
  return wrapper;
}